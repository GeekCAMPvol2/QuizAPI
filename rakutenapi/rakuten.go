package rakutenapi

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

type Service struct {
	ApplicationId string //アプリケーションID
	AffiliateId   string //アフェリエイトID
	BasePath      string //リクエストするベースURL
	RakutenSearch *RakutenSearchService
}

// 新しいRakutenSearchServiceを定義する
func NewRakutenSearch(s *Service) *RakutenSearchService {
	rs := &RakutenSearchService{s: s}
	return rs
}

// 情報を初期化する
func InitRequest() *Service {
	var srv Service
	err := godotenv.Load()
	if err != nil {
		log.Fatal("エラー！.envファイルが読み込めませんでした")
	}
	if len(os.Getenv("APPLICATION_ID")) == 0 {
		log.Panic("APPLICATION_IDが設定されていません")
		return nil
	}

	if len(os.Getenv("AFFILIATE_ID")) == 0 {
		log.Println("AFFILIATE_IDは設定されていません。")
	} else {
		srv.AffiliateId = os.Getenv("AFFILIATE_ID")
	}

	srv.ApplicationId = os.Getenv("APPLICATION_ID")
	srv.BasePath = "https://app.rakuten.co.jp"
	srv.RakutenSearch = NewRakutenSearch(&srv)
	return &srv
}

func (r *RakutenSearchService) Get() *RakutenSearch {
	return &RakutenSearch{s: r.s}
}

type RakutenSearchService struct {
	s *Service
}

// 楽天アフェリエイトIDを設定する
func (r *Service) AffId(AffiliateId string) *Service {
	r.AffiliateId = AffiliateId
	return r
}

type RakutenSearch struct {
	//API参考 https://webservice.rakuten.co.jp/documentation/ichiba-product-search
	s       *Service
	keyword string //UTF-8でエンコードした文字列。keyword GenreIDのどちらかは必須
	genreId string //楽天市場におけるジャンルを検索するためのID

	//実装予定なし
	// ProductId string //楽天プロダクト用の製品ID。他のAPIパラメタとの併用は不可
	// OrFlag               int  //複数キーワードが設定された場合に、AND検索、OR検索のいずれかが選択可能。 0:AND検索 1:OR検索

	hits uint64 //取得数。1~30までの整数
	page uint64 //ページ数 1~100までの整数
	// 	0：楽天標準ソート順
	//	1：発売日順（降順）
	//	2：発売日順（昇順）
	//	3：売上順（降順）
	//	4：売上順（昇順）
	//	5：満足順（降順）
	//	6：満足順（昇順）
	// ※UTF-8でURLエンコードされている必要があります。
	sort                 uint64
	minPrice             uint64 //検索時の最小値段設定。1以上999,999,999以下の整数
	maxPrice             uint64 //検索時の最大値段設定。1以上999,999,999以下の整数
	genreInformationFlag bool   //false :ジャンルごとの商品数の情報を取得しない。true :ジャンルごとの商品数の情報を取得する
}

// false :ジャンルごとの商品数の情報を取得しない。true :ジャンルごとの商品数の情報を取得する
func (r *RakutenSearch) GenreInformationFlag(GenreInformationFlag bool) *RakutenSearch {
	r.genreInformationFlag = GenreInformationFlag
	return r
}

// 検索時の最大値段設定。1以上999,999,999以下の整数
func (r *RakutenSearch) MaxPrice(maxPrice uint64) *RakutenSearch {
	r.maxPrice = maxPrice
	return r
}

// 検索時の最小値段設定。1以上999,999,999以下の整数
func (r *RakutenSearch) MinPrice(minPrice uint64) *RakutenSearch {
	r.minPrice = minPrice
	return r
}

// ソートの方法を設定
//
//	0：楽天標準ソート順
//	1：発売日順（降順）
//	2：発売日順（昇順）
//	3：売上順（降順）
//	4：売上順（昇順）
//	5：満足順（降順）
//	6：満足順（昇順）
//
// ※UTF-8でURLエンコードされている必要があります。
func (r *RakutenSearch) Sort(sort uint64) *RakutenSearch {
	r.sort = sort
	return r
}

// 検索するページを設定する
func (r *RakutenSearch) Page(page uint64) *RakutenSearch {
	r.page = page
	return r
}

// 検索の最大数数を設定する
func (r *RakutenSearch) Hits(Hits uint64) *RakutenSearch {
	r.hits = Hits
	return r
}

// 検索のキーワードを設定する
func (r *RakutenSearch) Keyword(SearchWord string) *RakutenSearch {
	r.keyword = url.QueryEscape(SearchWord)
	return r
}

// 楽天APIから取得をする
func (r RakutenSearch) Do() (AutoGenerated, error) {
	var responseBodyFromRakutenAPIData AutoGenerated

	urls := r.s.BasePath + "/services/api/IchibaItem/Search/20220601?format=json"
	urls += "&applicationId=" + r.s.ApplicationId

	//キーワード設定
	if len(r.keyword) == 0 && len(r.genreId) == 0 {
		return responseBodyFromRakutenAPIData, fmt.Errorf("keyword or itemCode is essential parameter")
	} else if len(r.keyword) != 0 {
		urls += "&keyword=" + url.QueryEscape(r.keyword)
	} else if len(r.genreId) != 0 {
		urls += "&genreId=" + url.QueryEscape(r.genreId)
	}

	//検索数
	if r.hits != 0 {
		urls += "&hits=" + strconv.FormatUint(r.hits, 10)
	}

	//検索ページ
	if r.page != 0 {
		urls += "&page=" + strconv.FormatUint(r.page, 10)
	}
	//ソート
	// 	0：楽天標準ソート順
	//	1：発売日順（降順）
	//	2：発売日順（昇順）
	//	3：売上順（降順）
	//	4：売上順（昇順）
	//	5：満足順（降順）
	//	6：満足順（昇順）
	switch r.sort {
	case 0:
		urls += "&Sort=standard"
	case 1:
		urls += "&Sort=-releaseDate"
	case 2:
		urls += "&Sort=+releaseDate"
	case 3:
		urls += "&Sort=-seller"
	case 4:
		urls += "&Sort=+seller"
	case 5:
		urls += "&Sort=-satisfied"
	case 6:
		urls += "&Sort=+satisfied"
	default:
		return responseBodyFromRakutenAPIData, fmt.Errorf("0-6の正しい値を入力してください")
	}

	//MinPrice
	if r.minPrice != 0 {
		urls += "&minPrice=" + strconv.FormatUint(r.minPrice, 10)
	}

	//MaxPrice
	if r.maxPrice != 0 {
		urls += "&maxPrice=" + strconv.FormatUint(r.maxPrice, 10)
	}

	//ジャンルごとの商品数取得フラグ
	if r.genreInformationFlag {
		urls += "&genreInformationFlag=1"
	} else {
		urls += "&genreInformationFlag=0"
	}

	body, err := requestServe(urls)
	err = json.Unmarshal(body, &responseBodyFromRakutenAPIData)

	if err != nil {
		log.Panic("Json.Unmarshal :", err)
	}

	return responseBodyFromRakutenAPIData, nil
}

func requestServe(urls string) ([]byte, error) {
	response, err := http.Get(urls)

	if err != nil {
		return nil, fmt.Errorf("API call failed. :%s", err)
	}

	defer response.Body.Close()
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Panic("ioutil.ReadAll :", err)
	}
	if len(body) == 0 {
		return nil, fmt.Errorf("bad request url:%s data:%s", urls, body)
	}
	return body, nil
}
